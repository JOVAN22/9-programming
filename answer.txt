3) The #! (shebang) tells the Linux kernel which interpreter to use to run the script. By using /usr/bin/env python3, the system searches your PATH for the Python 3 executable, making the script more portable across different Linux distributions.  I used the command chmod +x hello.py to change the file permissions to "executable." This allowed me to run the script directly as a program using ./hello.py instead of calling python3 hello.py.

run hello.py without typing python

chmod +x hello.py
 ./hello.py      
 
 
 
 4) The Difference: Compiler vs. Interpreter1. C uses a Compiler (The "Pre-Translated Book" approach)
 When you run gcc hello.c, the compiler looks at your entire file and translates it all at once into a brand-new file: a binary executable.Process: Source Code $\rightarrow$ Compiler $\rightarrow$ Machine Code (Executable File) $\rightarrow$ Run.Why it's "indirect": You can't run the .c file itself. You have to build the "machine-ready" version first.Advantage: Since the translation is already finished, the program runs incredibly fast.2. Python uses an Interpreter (The "Live Translator" approach)When you run python3 hello.py, a program called the Interpreter starts up. It reads your code line-by-line and translates it into instructions for the CPU on the fly.Process: Source Code $\rightarrow$ Interpreter (translates & executes line-by-line).Why it feels "direct": You don't have to create a second file. You just tell the interpreter "read this," and it starts working immediately.Advantage: It is much faster for the programmer to test and change code because there is no waiting for a "build" step.
 
 
 compile and run the C program
 
 gcc hello.c -o hello
 ./hello
